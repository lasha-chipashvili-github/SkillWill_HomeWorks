-- შესაძლო არსებული ცხრილების წაშლა
DROP TABLE IF EXISTS Cusromers;
DROP TABLE IF EXISTS Orders;
DROP TABLE IF EXISTS Shippings;
DROP TABLE IF EXISTS პროფესურა;
DROP TABLE IF EXISTS სტუდენტი_საგანი;
DROP TABLE IF EXISTS საგნები;
DROP TABLE IF EXISTS სტუდბილეთი;
DROP TABLE IF EXISTS სტუდენტობა;
DROP TABLE IF EXISTS ფაკულტეტები;


-- ცხრილების და ინდექსების შექმნა
CREATE TABLE სტუდენტობა(
	იდ INTEGER NOT NULL UNIQUE,
	სახელი VARCHAR NOT NULL,
	გვარი VARCHAR NOT NULL,
	პნ INTEGER NOT NULL UNIQUE,
	სტატუსი BOOLEAN DEFAULT TRUE,
	ფაკულტეტი INTEGER NOT NULL,
	საფეხური VARCHAR NOT NULL,
	კურსი INTEGER NOT NULL,
	PRIMARY KEY(იდ AUTOINCREMENT),
	FOREIGN KEY (ფაკულტეტი) REFERENCES ფაკულტეტები(იდ) ON DELETE SET NULL
);


CREATE INDEX სტუდ_ინდექს
ON სტუდენტობა (იდ);


CREATE TABLE ფაკულტეტები(
	იდ INTEGER NOT NULL UNIQUE,
	ფაკულტეტი VARCHAR NOT NULL UNIQUE,
	PRIMARY KEY(იდ AUTOINCREMENT)
);


CREATE TABLE პროფესურა(
	იდ INTEGER NOT NULL UNIQUE,
	სახელი VARCHAR NOT NULL,
	გვარი VARCHAR NOT NULL,
	პნ INTEGER NOT NULL UNIQUE,
	სტატუსი VARCHAR NOT NULL,
	ფაკულტეტი INTEGER NOT NULL,
	PRIMARY KEY(იდ AUTOINCREMENT),
	FOREIGN KEY (ფაკულტეტი) REFERENCES ფაკულტეტები(იდ) ON DELETE SET NULL
);


CREATE INDEX პროფ_ინდექს
ON პროფესურა (იდ);


CREATE TABLE საგნები(
	იდ INTEGER NOT NULL UNIQUE,
	დასახელება VARCHAR NOT NULL UNIQUE,
	კრედიტი INTEGER NOT NULL,
	PRIMARY KEY(იდ AUTOINCREMENT)
);


CREATE INDEX საგ_ინდექს
ON საგნები (იდ);


CREATE TABLE სტუდბილეთი(
	იდ INTEGER NOT NULL UNIQUE,
	სტუდენტი INTEGER NOT NULL UNIQUE,
	PRIMARY KEY (იდ AUTOINCREMENT),
	FOREIGN KEY (სტუდენტი) REFERENCES სტუდენტობა(იდ) ON DELETE SET NULL
);


CREATE TABLE სტუდენტი_საგანი(
	იდ INTEGER NOT NULL UNIQUE,
	სტუდენტი INTEGER,
	საგანი INTEGER,
	UNIQUE(სტუდენტი, საგანი), -- ერთი სტუდენტი ერთსა და იმავე საგანს რამდენჯერმე ვერ აირჩევს
	PRIMARY KEY(იდ AUTOINCREMENT),
	FOREIGN KEY (სტუდენტი) REFERENCES სტუდენტობა(იდ) ON DELETE SET NULL,
	FOREIGN KEY (საგანი) REFERENCES საგნები(იდ) ON DELETE SET NULL
);


--	სტუდენტობასა და სტუდბილეთს შორის არსებობს ერთი ერთთან მიმართება, ვინაიდან სტუდბილეთში
--	სტუდენტს უნიკალურობის შეზღუდვა აქვს დადებულილი;

-- სტუდენტობასა და საგნებს შორის არსებობს ბევრი ბევრთან მიმართება შუალედური ცხრილით სტუდენტი_საგანი;

-- სტუდენტობასა (პროფესურა) და ფაკულტეტებს შორის არის ერთი ბევრთან მიმართება, რამდენადაც 
-- სტუდენტობაში (პროფესურაში) ერთი პნ-ით მხოლოდ ერთი ინდივიდის შექმნა შეიძ₾ება, რომელსაც ერთი
-- ფაკულტეტი შეესაბამება, მაშინ როცა პირიქით, ცალკეულ ფაკულტეტს არაერთი სტუდენტი (პროფესორი) შეესაბამება;


-- მონაცემების შეტანა ცხრილებში
INSERT INTO ფაკულტეტები(იდ,ფაკულტეტი) VALUES
(1,"ყველაფრისმცოდნეობა"),
(2,"ექსპერტობა"),
(3,"გენერლობა"),
(4,"კომპიუტერული მეცნიერებები");


INSERT INTO სტუდენტობა(სახელი, გვარი, პნ, სტატუსი, ფაკულტეტი, საფეხური, კურსი) 
VALUES 
("დიდიე","დროგბა",100,TRUE,1,"BSc",1),
("ფრენკ","ლამპარდი",101,TRUE,2,"MSc",2),
("სტივენ","ჯერარდი",102,TRUE,3,"PhD",3),
("ზინედინ","ზიდანი",103,TRUE,4,"BSc",4),
("ლევ","იაშინი",104,TRUE,1,"BSc",2),
("ადა","ჰეგერბერგი",105,TRUE,2,"BSc",3),
("ჰარი","პოტერი",106,TRUE,3,"MSc",1),
("ამადეო","მოდილიანი",107,TRUE,4,"BSc",4),
("პაბლო","პიკასო",108,TRUE,1,"BSc",1),
("რიკარდო","კაკა",109,TRUE,2,"BSc",2),
("კვაჭი","კვაჭანტირაძე",110,TRUE,3,"MSc",2),
("მიშელ","პლატინი",111,TRUE,4,"BSc",1),
("ბიონსე","ნოულსი",112,TRUE,1,"BSc",2),
("პიერ-ლუიჯი","კოლინა",113,TRUE,2,"BSc",3),
("ოსვალდ","შპენგლერი",114,TRUE,3,"MSc",1),
("ფიდელ","კასტრო",115,TRUE,4,"PhD",2),
("პოლ","დირაკი",116,TRUE,1,"MSc",1);


INSERT INTO საგნები (იდ, დასახელება, კრედიტი) VALUES
(1,"ინგლისური",6),(2,"კომპიუტერი",3),(3,"სტრუქტურული გეოფიზიკა",3),
(4,"გეოპოლიტიკა",6),(5,"ალგორითმები და მონაცემთა სტრუქტურები",3),
(6,"პლაზმის ფიზიკა",3),(7,"ყველაფრის ისტორია",6),(8,"ანატომია",3),
(9,"ასტროლოგია",6),(10,"კომპიუტერის არქიტექტურა",3),
(11,"კალკულუსი",3),(12,"მანქანური სწავლება",3),
(13,"ხეზე კვეთა",6),(14,"რელიგია",6),(15,"მენეჯმენტი",6);


INSERT INTO პროფესურა (სახელი, გვარი, პნ, სტატუსი, ფაკულტეტი) VALUES
("ზიგმუნდ","ფროიდი",200,"სრული",1),
("დენზელ","ვაშინგტონი",201,"ასოცირებული",2),
("ჟორჟ","ბიზე",202,"ასისტენტ",3),
("ლინუს","ტორვალდსი",203,"სრული",4),
("გვიდო","ვან როსუმი",204,"ასოცირებული",1),
("ადრიან","ჰოლოვათი",205,"ასისტენტ",2),
("ენ","ჰეთუეი",206,"ასისტენტ",3),
("ანდრეი","ტუპოლევი",207,"ასოცირებული",4),
("ჯორჯ","კლუნი",208,"სრული",1),
("სტეფან","ვოლფრამი",209,"სრული",2);


INSERT INTO სტუდბილეთი (სტუდენტი) VALUES
(16),(15),(14),(13),(12),(11),(10),(9),
(8),(7),(6),(5),(4),(3),(2),(1);


INSERT INTO სტუდენტი_საგანი (სტუდენტი, საგანი) VALUES
(1,15),(3,13),(5,11),(7,9),
(9,7),(11,5),(13,3),(15,1),
(2,14),(4,12),(6,10),(8,8),
(10,6),(12,4),(14,2),(16,1),
(1,8),(3,5),(5,7),(7,4),
(9,11),(11,13),(13,15),(15,2),
(2,4),(4,6),(6,8),(8,10),
(10,12),(12,14),(14,1),(16,2),
(1,3),(3,4),(5,5),(7,6),
(9,3),(11,8),(13,9),(15,10),
(2,11),(4,11),(6,13),(8,14),
(10,15),(12,5),(14,10),(16,15);


-- განვახორციელოთ სხვადასვა მოთხოვნა შერწყმების გამოყენებით
SELECT სტ.სახელი, სტ.გვარი, სგ.დასახელება, სგ.კრედიტი
FROM სტუდენტობა AS სტ 
JOIN სტუდენტი_საგანი
ON სტ.იდ = სტუდენტი_საგანი.სტუდენტი
LEFT JOIN საგნები AS სგ
ON სგ.იდ = სტუდენტი_საგანი.საგანი
ORDER BY სტ.იდ;


-- FULL OUTER და RIGHT JOIN-ები ზოგ ონლაინ კომპილერსა და DB Browser for SQLite-ზე მხარდაჭერილი არ არის, ამიტომ
-- ამ მოთხოვნის გაშვება https://www.db-fiddle.com/ ბმულზე SQLite v3.39 ვერსიაზე შეიძლება, თუმცა ამ კონკეტულ
-- შემთხვევაში ჩვეულებრივი JOIN-იც იმავე შედეგს გვაძლევს, რასაც FULL OUTER JOIN მოგვცემდა
SELECT პრ.სახელი, პრ.გვარი, ფ.ფაკულტეტი
FROM პროფესურა AS პრ
JOIN ფაკულტეტები AS ფ
ON პრ.ფაკულტეტი = ფ.იდ;


SELECT სტ.სახელი, სტ.გვარი, ფ.ფაკულტეტი
FROM სტუდენტობა AS სტ
JOIN ფაკულტეტები AS ფ
ON სტ.ფაკულტეტი = ფ.იდ;


-- ახლა ლოგიკა განსაზღვრული არ არის, თუ რომელი საგანი რომელ ფაკულტეტს ეკუთვნის, ამიტომაც მათ შერწყმას ლოგიკა 
-- არ აქვს, ამიტომაც ჯვარედინი შერწყმის დემონსტრირებისთვის მშვენიერი წყვილია
SELECT სგ.დასახელება, სგ.კრედიტი, ფაკულტეტები.ფაკულტეტი
FROM საგნები AS სგ
CROSS JOIN ფაკულტეტები